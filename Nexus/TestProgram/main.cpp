/*
*	Demo of NEXUS
* 
*	Files like this will prob be generated by some sort
*	of Nexus GUI editor
*/
#include "../Engine/nexus.h"
#include "../Engine/gameObject.h"
#include "../Engine/camera.h"
#include "../Engine/scene.h"
#include "../Engine/module.h"

// For basic rotation of our object
#define GLM_FORCE_RADIANS
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>

#include <chrono>

int main() {
	int api = Nexus::RENDER_VULKAN;
#ifdef WIN32
	int msgBox = MessageBox(
		NULL,
		(LPCWSTR)L"Press OK for Vulkan, Cancel for OpenGL",
		(LPCWSTR)L"Nexus: Render API Select",
		MB_ICONINFORMATION | MB_OKCANCEL | MB_DEFBUTTON1
	);

	switch (msgBox) {
	case IDCANCEL:
		api = Nexus::RENDER_GL;
		break;
	case IDOK:
		api = Nexus::RENDER_VULKAN;
		break;
	}
#endif
	// Create properties so Nexus knows whats up
	Nexus::GameProperties gm;
	gm.gameName = "Nexus Engine Demo";
	gm.windowHeight = 800;
	gm.windowWidth = 600;
	gm.renderer = api;

	Nexus::Engine* engine = new Nexus::Engine(gm);

	// Load audio module
	Nexus::Module audio("Audio.dll");
	audio.initClass("Audio");
	audio.runFunction("Audio", "initAudio");
	//audio.runFunction("Audio", "playAudio", 1, "test.mp3");

	Nexus::Scene testScene("Test Scene");

	// Since we use the same shader for both of these objects, just make one
	Nexus::Shader vert("../shaders/vertex.gl", "../shaders/vert.spv");
	Nexus::Shader frag("../shaders/frag.gl","../shaders/frag.spv");

	Nexus::GameObject gameObject("Test Object");

	std::vector<Nexus::Vertex> verts = {
		{{-0.5f, -0.5f, 0.0f}, {1.0f, 0.0f, 0.0f}},
		{{0.5f, -0.5f, 0.0f}, {0.0f, 1.0f, 0.0f}},
		{{0.5f, 0.5f, 0.0f}, {0.0f, 0.0f, 1.0f}},
		{{-0.5f, 0.5f, 0.0f}, {1.0f, 1.0f, 1.0f}}
	};

	std::vector<uint16_t> inds = {
		0, 1, 3, 1, 2, 3
	};

	gameObject.mesh = new Nexus::Mesh(verts, inds);
	gameObject.setVertShader(&vert);
	gameObject.setFragShader(&frag);

	testScene.addObject(&gameObject);

	// Next object
	std::vector<Nexus::Vertex> verts_new = {
		{{-1.0f, -1.0f, 0.0f}, {0.0f, 1.0f, 0.3f}},
		{{0.0f, -0.0f, 0.0f}, {0.0f, 1.0f, 0.5f}},
		{{-1.0f, 1.0f, 0.0f}, {0.0f, 1.0f, 1.0f}}
	};

	std::vector<uint16_t> inds_new = {
		0, 1, 2
	};

	Nexus::GameObject test2("Test Object 2");

	test2.mesh = new Nexus::Mesh(verts_new, inds_new);
	test2.setVertShader(&vert);
	test2.setFragShader(&frag);

	testScene.addObject(&test2);

	// Let's get our camera
	Nexus::Camera camera;
	engine->SetCamera(&camera);

	engine->InitScene(&testScene);

	while (1) {
		static auto sT = std::chrono::high_resolution_clock::now();
		auto cT = std::chrono::high_resolution_clock::now();
		float t = std::chrono::duration<float, std::chrono::seconds::period>(cT - sT).count();

		camera.camData = Nexus::CameraData{};

		camera.camData.model = glm::rotate(glm::mat4(1.0f), t * glm::radians(90.0f), glm::vec3(0.0f, 0.0f, 1.0f));
		camera.camData.view = glm::lookAt(glm::vec3(2.0f, 2.0f, 2.0f), glm::vec3(0.0f, 0.0f, 0.0f), glm::vec3(0.0f, 0.0f, 1.0f));
		camera.pAngle = 10 * std::abs(std::cos(t)) + 35;

		engine->Update(&testScene);
	}
}